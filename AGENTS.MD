## Agents guide for `website`

This document provides operational guardrails and workflows for AI agents automating tasks in this repository. Follow these instructions to avoid breaking local/dev/CI flows and to keep changes safe and reproducible.

### Core principles
- Prefer Makefile targets over ad‑hoc commands. Discover targets via:
```bash
make help
```
- Default to Docker-based workflows. For host-only runs, prefix with `CI=1`.
- Keep edits minimal, typed, and conforming to existing style. Always run format and lints before concluding.
- Avoid destructive Docker operations (volume pruning, network removal) unless explicitly requested.

### Tech overview
- Next.js 15 (React 18, TypeScript), static export served from `out`.
- MUI v6 + Emotion, i18n via `i18next`/`react-i18next`.
- Swagger UI (`swagger-ui-react`), schema auto-fetched and patched during dev/build.
- Testing: Jest (+jsdom/node), Playwright (E2E/visual), K6 (load), Memlab (memory), Stryker (mutation).
- Tooling: ESLint, Prettier, Lighthouse CI, Storybook.

### Environment variables (minimum for local)
Create or update `.env` (Makefile auto-includes):
```env
WEBSITE_DOMAIN=localhost
DEV_PORT=3000
NEXT_PUBLIC_PROD_PORT=3001
NEXT_PUBLIC_PROD_HOST_API_URL=http://localhost:3001
NEXT_PUBLIC_PROD_CONTAINER_API_URL=http://prod:3001
# Optional headers for tests/audits
NEXT_PUBLIC_CONTINUOUS_DEPLOYMENT_HEADER_NAME=X-My-Header
NEXT_PUBLIC_CONTINUOUS_DEPLOYMENT_HEADER_VALUE=some-value
```
Notes:
- Docker dev uses polling for file watching (set in `docker-compose.yml`).
- Playwright/Lighthouse read public host/container URLs from env.

### Safe command patterns
- Prefer these:
```bash
make start                # Dev (Docker) → http://localhost:3000
CI=1 make start           # Dev on host
make start-prod           # Build+serve static export at NEXT_PUBLIC_PROD_PORT
make build-out            # Build ./out locally
make format && make lint  # Prettier + ESLint + tsc + markdownlint
```
- Tests:
```bash
make test-unit-all        # Jest (client+server)
make test-e2e             # Playwright E2E (runs inside Docker)
make test-e2e-ui          # Playwright UI mode
make test-visual          # Visual regression
make test-visual-update   # Update snapshots
make load-tests           # K6
make test-memory-leak     # Memlab
```
- Storybook & audits:
```bash
make storybook-start
make lighthouse-desktop
make lighthouse-mobile
```
- Docker helpers:
```bash
make ps
make logs
make new-logs
make sh
make down
make stop
```

### Guardrails for automation
- Do not run interactive commands; pass non-interactive flags where applicable and avoid pagers.
- Do not hardcode ports/hosts; read from env vars as above.
- Do not rewrite `public/swagger-schema.json` manually unless the task requires it—use `scripts/fetchSwaggerSchema.mjs` and `scripts/patchSwaggerServer.mjs` flows.
- Do not introduce unresolved TODOs or commented-out code. Implement fully or skip with justification.
- Respect TypeScript strictness; avoid `any` and unsafe casts.
- Maintain import paths via `tsconfig.paths.json` and avoid breaking path aliases.

### Editing guidance
- Code style:
  - Use explicit, descriptive names; avoid terse identifiers.
  - Prefer early returns and simple control flow.
  - Add concise comments for complex logic (explain “why”, not “how”).
- Internationalization:
  - New copy should use i18n. The localization file is generated by `scripts/localizationGenerator.js` during builds; ensure a dev/build run occurs after adding keys.
- Components/pages:
  - Place new pages under `pages/`; reusable UI in `src/components/`.
  - Keep UI consistent with MUI theme and existing patterns.

### Verification checklist (run before finishing a task)
```bash
make format
make lint
make test-unit-all
make start-prod && make test-e2e
```
Artifacts/Reports:
- Playwright HTML report: `playwright-report/index.html`
- Lighthouse reports: `lhci-reports-desktop/`, `lhci-reports-mobile/`
- Coverage: `coverage/`

### Typical workflows
- Implement feature/fix:
  1) Branch and edit files.
  2) `make format && make lint`.
  3) `make test-unit-all`.
  4) `make start-prod && make test-e2e` (and visual if UI change).
- Update dependencies cautiously:
  - Host only: `make update` (updates lockfile). Do not run inside containers.
  - After updates: `make format && make lint && make test-unit-all`.
- Performance check:
  - `make build-analyze` to open bundle analyzer.
  - `make lighthouse-desktop` and/or `make lighthouse-mobile`.

### Scripts reference
- `scripts/localizationGenerator.js`: runs inside webpack via `next.config.js`.
- `scripts/fetchSwaggerSchema.mjs`: fetches schema.
- `scripts/patchSwaggerServer.mjs`: rewrites servers for dev/prod/test.
- `scripts/cloudfront_routing.js`: CDN routing helper.
- `scripts/get-pr-comments.sh`: PR utilities.

### CI/commit conventions
- Conventional commits are enforced (commitlint). Examples:
  - `feat(ui): add dark mode toggle`
  - `fix(swagger): rewrite servers for staging`
  - `chore: bump deps`

### Troubleshooting
- Dev container not ready: `make create-network` then `make start`; ensure port `3000` is free.
- Prod health timeout: confirm `NEXT_PUBLIC_PROD_PORT` and logs via `make new-logs`.
- Playwright base URL issues: check `NEXT_PUBLIC_PROD_CONTAINER_API_URL` when running in Docker.

### When to ask for confirmation
- Any task requiring destructive operations (data/volume/network removal).
- Changing API schemas, security settings, or external endpoints.
- Large refactors spanning many files or public interfaces.

### Code Review Workflow and PR Refactoring

#### Automated Code Review Comment Retrieval

**CRITICAL**: Always use `make pr-comments` to retrieve and address all code review comments systematically.

The repository provides an automated workflow to fetch all unresolved PR comments and address them methodically.

#### Using the PR Comments Command

Basic usage:
```bash
make pr-comments                    # Auto-detect PR from current branch
make pr-comments PR=215             # Specify PR number explicitly
make pr-comments FORMAT=json        # Output in JSON format
make pr-comments FORMAT=markdown    # Output in Markdown format
```

Command features:
- **Auto-detection**: Detects PR number from current git branch.
- **Multiple formats**: Text (default), JSON, Markdown.
- **GitHub Enterprise support**: Configure via `GITHUB_HOST` env var.
- **Comprehensive output**: File paths, line numbers, authors, timestamps, URLs.
- **Unresolved focus**: Retrieves only unresolved comments needing action.

#### Code Review Refactoring Workflow

**MANDATORY**: Follow this systematic approach for addressing review feedback.

1) Retrieve All Code Review Comments
```bash
make pr-comments
```
Shows for each unresolved comment: file path, line number, author, timestamps, full content, and GitHub URL.

2) Analyze Comment Types and Prioritize
- **A. Committable Suggestions (Highest Priority)**
  - Suggested code changes you can apply verbatim (often GitHub suggestions/code blocks).
  - Action: Apply exactly as provided.
- **B. LLM Prompts and Instructions (High Priority)**
  - Specific refactoring directions or architectural guidance.
  - Action: Use as prompts for implementation/refactoring.
- **C. Questions and Clarifications (Medium Priority)**
  - Action: Reply clearly; improve code self-documentation if needed.
- **D. General Feedback (Low Priority)**
  - Action: Consider for future improvements.

3) Systematic Implementation Strategy
- **Committable Suggestions**
  - Apply suggestion directly, then commit:
  ```bash
  git add -A
  git commit -m "chore(review): apply reviewer suggestion <short summary>"
  ```

- **LLM/Instructional Comments**
  - Steps:
    1. Analyze current implementation and impacts.
    2. Design the change (respect SOLID and existing patterns).
    3. Implement with small, reviewable edits.
    4. Update/add tests.
    5. Verify with repo checks (see below).

- **Complex Refactoring Requests**
  - Break into small commits:
    1. Introduce interfaces/abstractions.
    2. Implement new classes/functions.
    3. Migrate usage to new structure.
    4. Remove deprecated code.
    5. Update tests and relevant docs.

4) Quality Assurance After Each Change
Run after addressing each comment or related group:
```bash
make format              # Prettier
make lint                # ESLint + tsc + markdownlint
make test-unit-all       # Jest client/server
make start-prod && make test-e2e  # Playwright E2E when applicable
# Optional depth checks:
make test-visual         # Visual regression (UI changes)
make test-mutation       # Stryker mutation tests (significant logic)
```

5) Documentation and Verification
- Update docs when comments imply changes to:
  - API docs, README, inline code comments, ADRs.
- Verify changes meet requirements:
  - All tests pass; coverage acceptable.
  - No regressions; quality gates green.
  - Architectural boundaries respected.

6) Comment Response Strategy
- **Questions**: Provide concise, direct answers.
- **Implemented suggestions**: Reply with commit hash/links addressing the comment.
- **Complex refactors**: Explain approach and reference commits/PR discussion.
- **Cannot implement**: Explain constraints and propose alternatives.

#### Advanced Code Review Patterns
- **Conflicting comments**: Prioritize architectural correctness over style; discuss conflicts with reviewers; document decisions.
- **Large-scale refactors**: Separate logical changes into distinct commits; maintain backward compatibility where possible; update tests incrementally; consider feature flags for risky changes.
- **Performance & security**: Address security first; benchmark performance-sensitive changes; document trade-offs.

#### Integration with Development Workflow
- Before starting:
```bash
git status                  # Ensure clean working tree
git pull origin main        # Rebase/merge latest changes as needed
make pr-comments            # Current unresolved comments
```
- During refactoring:
  - Tackle one comment/group at a time.
  - Commit frequently with descriptive messages and comment URLs for traceability.
- After completing all comments:
```bash
make lint && make test-unit-all
make start-prod && make test-e2e
make pr-comments            # Ensure no unresolved comments remain
git push
```

This workflow ensures feedback is addressed thoroughly while maintaining code quality and repository standards.
